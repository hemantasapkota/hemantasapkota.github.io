{
  "author": {
    "name": "Mario Casciaro"
  },
  "name": "scatter",
  "description": "IoC container and out-of-the-box extensibility for Node.js applications",
  "homepage": "https://github.com/mariocasciaro/scatter",
  "version": "0.7.3",
  "repository": {
    "type": "git",
    "url": "git://github.com/mariocasciaro/scatter.git"
  },
  "main": "lib/index.js",
  "dependencies": {
    "lodash": "~2.4.1",
    "minimatch": "~0.2.12",
    "glob": "~3.2.3",
    "readdirp": "~0.3.1",
    "inherits": "~2.0.0",
    "async": "~0.2.9",
    "when": "~3.0.1"
  },
  "devDependencies": {
    "chai": "~1.8.1",
    "mocha": "~1.15.1",
    "rimraf": "~2.2.2",
    "mocha-lcov-reporter": "0.0.1",
    "coveralls": "~2.6.0",
    "istanbul": "~0.1.46",
    "benchpress": "~0.1.2"
  },
  "scripts": {
    "test": "node ./node_modules/istanbul/lib/cli.js cover ./node_modules/mocha/bin/_mocha test/*.js --report html -- -R spec"
  },
  "keywords": [
    "dependency injection",
    "inversion of control",
    "extensibility",
    "plugin system",
    "architecture",
    "hooks",
    "ioc"
  ],
  "license": "MIT",
  "readme": "![Scatter logo](https://raw2.github.com/mariocasciaro/resources/master/scatter_text_lg.png)\n\n[![NPM version](https://badge.fury.io/js/scatter.png)](http://badge.fury.io/js/scatter)\n[![Build Status](https://travis-ci.org/mariocasciaro/scatter.png)](https://travis-ci.org/mariocasciaro/scatter)\n[![Coverage Status](https://coveralls.io/repos/mariocasciaro/scatter/badge.png)](https://coveralls.io/r/mariocasciaro/scatter)\n[![Dependency Status](https://gemnasium.com/mariocasciaro/scatter.png)](https://gemnasium.com/mariocasciaro/scatter)\n\nScatter is an **Inversion of Control (IoC) container** for Node.js. Scatter allows you to split your project in **particles** (components), and then uses **Dependency Injection** and **Service locator** to link your modules together.\n\nApplications created with Scatter are **extensible out-of-the box**. Since every dependency is \"virtual\", you can override and extend every module. In addition by using Scatter [Services](#services) you can provide explicit extension points to your application.\n\nEvery module created for Scatter is totally agnostic to the IoC container and **can be used even without it**. Scatter modules are POJOs (Plain Old Javascript Objects), simply objects, factories and constructors that accept their dependencies as input. The only difference from a *plain* module is that Scatter reads an annotation named `__module` to extract the information to initialize the module and inject dependencies.\n\n-----\n\n### [Full Guide](https://github.com/mariocasciaro/scatter/wiki/Guide) | [API docs](https://github.com/mariocasciaro/scatter/wiki/API-Documentation)\n\n-----\n\n## Features\n\n* Split your project into **components (particles)** and wire  modules using **Dependency Injection**.\n* Define your modules as you want: factories, constructors or plain objects. \n* Your modules do not need to know who is instantiating them or wiring them, they are totally **decoupled from Scatter and will work even without it**.\n* Instantiate and initialize modules **asynchronously** (just return a promise).\n* **Services framework** built on top of the IoC container (with sync and async execution)\n\n## Examples\n\nIf you prefer to go straight to the code then take a look at some [examples](https://github.com/mariocasciaro/scatter/tree/master/examples).\n\n## Sample usage\n\nThe directory structure below shows 3 particles (Scatter components): \n* `core` the the main application\n* 2 plugins: \n  * `privateProfiles`\n  * `admin`\n\nAll the 3 components define some routes. The Scatter container allows you to write each component **as if it they were all included in a single app root, as if all the sources were actually contained in a single directory** (and not scattered across different components). \n\nIn this examples `routes` is for Scatter a `namespace` not a physical directory, it is a **federated container of modules**.\n\n```\napp.js\ncore\n|-- particle.json\n|-- expressApp.js\n|-- routes                <--- Routes\n    |-- home.js\n    `-- profiles.js\n|-- data\n    `-- db.js\nplugins\n|-- privateProfiles\n    |-- particle.json\n    `-- routes            <--- Routes\n        |-- profiles.js   <--- an override\n        `-- private.js\n|-- admin\n    |-- particle.json\n    `-- routes            <--- Routes\n        `-- admin.js\n```\n\nNow if we wanted to register all the routes in our express application, the file `core/expressApp.js.js` would look like:\n\n```javascript\n// file \"core/expressApp.js.js\"\n\nvar express = require('express'),\n  http = require('http');\n\nmodule.exports = function(homeRouter, profileRouter, privateRouter, adminRouter) {\n    return {\n        start: function() {\n            var app = express();\n            app.use(...);\n            [... middleware ...]\n            app.use(app.router);\n            \n            //now we register our routes\n            homeRouter.register(app);\n            profileRouter.register(app);\n            privateRouter.register(app);\n            adminRouter.register(app);\n            \n            \n            http.createServer(app).listen(app.get('port'), function () {\n              console.log('Express server listening on port ' + app.get('port'));\n            });\n        }\n    };\n};\n//The Scatter annotation\nmodule.exports.__module = {\n    //Inject this modules are arguments\n    args: [\"routes/home\", \"routes/profiles\", \"routes/private\", \"routes/admin\"]\n};\n```\n\nThen at last the file `app.js` would bootstrap the Scatter container and start the express app:\n\n```javascript\nvar scatter = new Scatter();\nscatter.registerParticles([\n  __dirname + '/plugins/*',\n  __dirname + '/core'\n]);\n\n//The application entry point, the dependency is loaded explicitly\nscatter.load(\"expressApp\").then(function(expressApp) {\n    expressApp.start();\n});\n```\n\n\n## More decoupling: Services\n\nYou will notice in the example above that if a new plugins is added and a new route is introduced it will not be \nregistered, because we reference directly the routes in the file `core/expressApp`. To solve this problem Scatter \nsupports a pattern that is a mix between DI and service locator. \nThe `svc` (Service) plugin will allow you to **require a method defined in multiple modules as a dependency**!\n\nUsing Scatter Services the `core/expressApp` would now look like:\n\n```javascript\n// file \"core/expressApp.js.js\"\n\nvar express = require('express'),\n  http = require('http');\n\nmodule.exports = function(registerAllRoutes) {\n    return {\n        start: function() {\n            var app = express();\n            app.use(...);\n            [... middleware ...]\n            app.use(app.router);\n            \n            //now we register our routes\n            registerAllRoutes(app);\n            \n            http.createServer(app).listen(app.get('port'), function () {\n              console.log('Express server listening on port ' + app.get('port'));\n            });\n        }\n    };\n};\n//The Scatter annotation\nmodule.exports.__module = {\n    //Inject a service as dependency\n    args: [\"svc!routes/register\"]\n};\n```\n\n## Documentation\n\n**There is a lot more to know!** Take a look at the guide and the API docs.\n\n### [Full Guide](https://github.com/mariocasciaro/scatter/wiki/Guide)\n### [API docs](https://github.com/mariocasciaro/scatter/wiki/API-Documentation)\n\n## What's new\n\n#### 0.7\n\n* Support for relative paths in module dependencies.\n* **Breaking changes**:\n    * Services must now be defined using the full service namespace.\n      ```\n      provides: 'aService'\n      ```\n      Now becomes:\n      ```\n      provides: 'full/namespace/aService'\n      ```\n    * When requiring services without arguments (e.g. `svc!aService`) the `sequence` \n      service invocator will be returned instead of the full service object. \n      In practice now `svc!aService` === `svc|sequence!aService`.\n    \n#### 0.6\n\n* Several internal improvement, including plugin system refactoring, new benchmarking framework, performance optimizations.\n* **Breaking changes**:\n  * The `log` object provided to the Scatter constructor must expect `trace, debug, info, warn, error` as levels instead of `silly, verbose, info, warn, error`.\n\n[Full changelog](https://github.com/mariocasciaro/scatter/blob/master/CHANGES.md)\n\n## Stability\n\n#### 2 - Unstable\n\nThe API is in the process of settling, but has not yet had\nsufficient real-world testing to be considered stable.\n\n# Contributors\n\n* [Mario Casciaro](https://github.com/mariocasciaro) - Twitter [@mariocasciaro](https://twitter.com/mariocasciaro) - Creator\n* Zbigniew Mrowinski - Twitter [@MrowinskiZ](https://twitter.com/MrowinskiZ) - Scatter logo\n\n-----\n\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/mariocasciaro/scatter/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mariocasciaro/scatter/issues"
  },
  "_id": "scatter@0.7.3",
  "dist": {
    "shasum": "d09605fbf626414652e543604bb5aaefe9cf2594"
  },
  "_from": "scatter@~0.7.0",
  "_resolved": "https://registry.npmjs.org/scatter/-/scatter-0.7.3.tgz"
}
